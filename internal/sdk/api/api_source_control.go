/*
Retool API

Go to Settings > API to get started. Once you generate an API token, use bearer token authentication to make requests.

API version: 2.9.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SourceControlAPIService SourceControlAPI service
type SourceControlAPIService service

type ApiSourceControlConfigDeleteRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlConfigDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SourceControlConfigDeleteExecute(r)
}

/*
SourceControlConfigDelete Delete source control provider configuration

Deletes source control provider configuration for organization or space. The API token must have the "Source Control > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlConfigDeleteRequest
*/
func (a *SourceControlAPIService) SourceControlConfigDelete(ctx context.Context) ApiSourceControlConfigDeleteRequest {
	return ApiSourceControlConfigDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SourceControlAPIService) SourceControlConfigDeleteExecute(r ApiSourceControlConfigDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlConfigDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSourceControlConfigGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlConfigGetRequest) Execute() (*SourceControlConfigGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlConfigGetExecute(r)
}

/*
SourceControlConfigGet Get source control configuration

Returns the source control provider configuration for the organization or space. The API token must have the "Source Control > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlConfigGetRequest
*/
func (a *SourceControlAPIService) SourceControlConfigGet(ctx context.Context) ApiSourceControlConfigGetRequest {
	return ApiSourceControlConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlConfigGet200Response
func (a *SourceControlAPIService) SourceControlConfigGetExecute(r ApiSourceControlConfigGetRequest) (*SourceControlConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlConfigPostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	sourceControlConfigPutRequest *SourceControlConfigPutRequest
}

func (r ApiSourceControlConfigPostRequest) SourceControlConfigPutRequest(sourceControlConfigPutRequest SourceControlConfigPutRequest) ApiSourceControlConfigPostRequest {
	r.sourceControlConfigPutRequest = &sourceControlConfigPutRequest
	return r
}

func (r ApiSourceControlConfigPostRequest) Execute() (*SourceControlConfigPost200Response, *http.Response, error) {
	return r.ApiService.SourceControlConfigPostExecute(r)
}

/*
SourceControlConfigPost Create source control configuration

Create source control provider configuration for the organization or space and returns the created configuration. This will result in an error if configuration already is already set. The API token must have the "Source Control > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlConfigPostRequest
*/
func (a *SourceControlAPIService) SourceControlConfigPost(ctx context.Context) ApiSourceControlConfigPostRequest {
	return ApiSourceControlConfigPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlConfigPost200Response
func (a *SourceControlAPIService) SourceControlConfigPostExecute(r ApiSourceControlConfigPostRequest) (*SourceControlConfigPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlConfigPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlConfigPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlConfigPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlConfigPutRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	sourceControlConfigPutRequest *SourceControlConfigPutRequest
}

func (r ApiSourceControlConfigPutRequest) SourceControlConfigPutRequest(sourceControlConfigPutRequest SourceControlConfigPutRequest) ApiSourceControlConfigPutRequest {
	r.sourceControlConfigPutRequest = &sourceControlConfigPutRequest
	return r
}

func (r ApiSourceControlConfigPutRequest) Execute() (*SourceControlConfigPut200Response, *http.Response, error) {
	return r.ApiService.SourceControlConfigPutExecute(r)
}

/*
SourceControlConfigPut Set source control configuration

Creates or updates the source control provider configuration for the organization or space. This will overwrite any existing configuration. The API token must have the "Source Control > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlConfigPutRequest
*/
func (a *SourceControlAPIService) SourceControlConfigPut(ctx context.Context) ApiSourceControlConfigPutRequest {
	return ApiSourceControlConfigPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlConfigPut200Response
func (a *SourceControlAPIService) SourceControlConfigPutExecute(r ApiSourceControlConfigPutRequest) (*SourceControlConfigPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlConfigPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlConfigPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlConfigPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlDeployPostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlDeployPostRequest) Execute() (*SourceControlDeployPost200Response, *http.Response, error) {
	return r.ApiService.SourceControlDeployPostExecute(r)
}

/*
SourceControlDeployPost Trigger deployment of latest changes

Deploys the latest changes from the source control provider to the instance. You can use the GET /deployment/{id} endpoint to check the status of the deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlDeployPostRequest
*/
func (a *SourceControlAPIService) SourceControlDeployPost(ctx context.Context) ApiSourceControlDeployPostRequest {
	return ApiSourceControlDeployPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlDeployPost200Response
func (a *SourceControlAPIService) SourceControlDeployPostExecute(r ApiSourceControlDeployPostRequest) (*SourceControlDeployPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlDeployPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlDeployPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlDeploymentIdGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	id string
}

func (r ApiSourceControlDeploymentIdGetRequest) Execute() (*SourceControlDeployPost200Response, *http.Response, error) {
	return r.ApiService.SourceControlDeploymentIdGetExecute(r)
}

/*
SourceControlDeploymentIdGet Get a deployment

Get the status of a deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The deployment ID
 @return ApiSourceControlDeploymentIdGetRequest
*/
func (a *SourceControlAPIService) SourceControlDeploymentIdGet(ctx context.Context, id string) ApiSourceControlDeploymentIdGetRequest {
	return ApiSourceControlDeploymentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SourceControlDeployPost200Response
func (a *SourceControlAPIService) SourceControlDeploymentIdGetExecute(r ApiSourceControlDeploymentIdGetRequest) (*SourceControlDeployPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlDeployPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlDeploymentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/deployment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlManifestsGetRequest) Execute() (*SourceControlManifestsGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsGetExecute(r)
}

/*
SourceControlManifestsGet Lists all release manifests

Returns a list of all release manifests available in the source control repository. The API token must have the "Source control > Releases (Read)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlManifestsGetRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsGet(ctx context.Context) ApiSourceControlManifestsGetRequest {
	return ApiSourceControlManifestsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlManifestsGet200Response
func (a *SourceControlAPIService) SourceControlManifestsGetExecute(r ApiSourceControlManifestsGetRequest) (*SourceControlManifestsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	appUuid string
	manifestName string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameAppsAppUuidDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameAppsAppUuidDeletePost Delete the entry for an app from a release manifest

NOTE: This endpoint is deprecated. Use the DELETE /manifests/{manifestName}/{elementUuid} endpoint instead. 

Push a branch to the source control repository that deletes the entry for the specified app from the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid to specify an app of interest within the release manifest. This should be the uuid found in the source control repository, which may differ from the organization specific uuid.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest

Deprecated
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameAppsAppUuidDeletePost(ctx context.Context, appUuid string, manifestName string) ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest {
	return ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *SourceControlAPIService) SourceControlManifestsManifestNameAppsAppUuidDeletePostExecute(r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameAppsAppUuidDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/apps/{appUuid}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	appUuid string
	manifestName string
	sourceControlManifestsManifestNameAppsAppUuidPutRequest *SourceControlManifestsManifestNameAppsAppUuidPutRequest
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) SourceControlManifestsManifestNameAppsAppUuidPutRequest(sourceControlManifestsManifestNameAppsAppUuidPutRequest SourceControlManifestsManifestNameAppsAppUuidPutRequest) ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest {
	r.sourceControlManifestsManifestNameAppsAppUuidPutRequest = &sourceControlManifestsManifestNameAppsAppUuidPutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameAppsAppUuidPutExecute(r)
}

/*
SourceControlManifestsManifestNameAppsAppUuidPut Set release manifest

NOTE: This endpoint is deprecated. Use the PUT /manifests/{manifestName}/{elementUuid} endpoint instead. 

Push a branch to the source control repository that updates the release version of the specified app in the named release manifest. If the manifest does not already exist, it will be created in the branch. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid to specify an app of interest within the release manifest. This should be the uuid found in the source control repository, which may differ from the organization specific uuid.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest

Deprecated
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameAppsAppUuidPut(ctx context.Context, appUuid string, manifestName string) ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest {
	return ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *SourceControlAPIService) SourceControlManifestsManifestNameAppsAppUuidPutExecute(r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameAppsAppUuidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameAppsAppUuidPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameDeletePostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	manifestName string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

func (r ApiSourceControlManifestsManifestNameDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameDeletePost Delete a release manifest

Push a branch to the source control repository that deletes the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameDeletePostRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameDeletePost(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNameDeletePostRequest {
	return ApiSourceControlManifestsManifestNameDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *SourceControlAPIService) SourceControlManifestsManifestNameDeletePostExecute(r ApiSourceControlManifestsManifestNameDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	elementUuid string
	manifestName string
	elementType *string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

// The type of the element.
func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) ElementType(elementType string) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameElementUuidDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameElementUuidDeletePost Delete the entry for an app from a release manifest

Push a branch to the source control repository that deletes the entry for the specified element from the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid to specify an element of interest within the release manifest.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameElementUuidDeletePost(ctx context.Context, elementUuid string, manifestName string) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	return ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *SourceControlAPIService) SourceControlManifestsManifestNameElementUuidDeletePostExecute(r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameElementUuidDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/{elementUuid}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameElementUuidPutRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	elementUuid string
	manifestName string
	elementType *string
	sourceControlManifestsManifestNameAppsAppUuidPutRequest *SourceControlManifestsManifestNameAppsAppUuidPutRequest
}

// The type of the element.
func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) ElementType(elementType string) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) SourceControlManifestsManifestNameAppsAppUuidPutRequest(sourceControlManifestsManifestNameAppsAppUuidPutRequest SourceControlManifestsManifestNameAppsAppUuidPutRequest) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	r.sourceControlManifestsManifestNameAppsAppUuidPutRequest = &sourceControlManifestsManifestNameAppsAppUuidPutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameElementUuidPutExecute(r)
}

/*
SourceControlManifestsManifestNameElementUuidPut Set release manifest

Push a branch to the source control repository that updates the release version of the specified element in the named release manifest. If the manifest does not already exist, it will be created in the branch. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid to specify an element of interest within the release manifest.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameElementUuidPutRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameElementUuidPut(ctx context.Context, elementUuid string, manifestName string) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	return ApiSourceControlManifestsManifestNameElementUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *SourceControlAPIService) SourceControlManifestsManifestNameElementUuidPutExecute(r ApiSourceControlManifestsManifestNameElementUuidPutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameElementUuidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameAppsAppUuidPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	manifestName string
}

func (r ApiSourceControlManifestsManifestNameGetRequest) Execute() (*SourceControlManifestsManifestNameGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameGetExecute(r)
}

/*
SourceControlManifestsManifestNameGet Get a specific release manifest

Returns the release manifest with the specified name from the source control repository if it exists. The API token must have the "Source control > Releases (Read)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameGetRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNameGet(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNameGetRequest {
	return ApiSourceControlManifestsManifestNameGetRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNameGet200Response
func (a *SourceControlAPIService) SourceControlManifestsManifestNameGetExecute(r ApiSourceControlManifestsManifestNameGetRequest) (*SourceControlManifestsManifestNameGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNameGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNamePutRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	manifestName string
	sourceControlManifestsManifestNamePutRequest *SourceControlManifestsManifestNamePutRequest
}

func (r ApiSourceControlManifestsManifestNamePutRequest) SourceControlManifestsManifestNamePutRequest(sourceControlManifestsManifestNamePutRequest SourceControlManifestsManifestNamePutRequest) ApiSourceControlManifestsManifestNamePutRequest {
	r.sourceControlManifestsManifestNamePutRequest = &sourceControlManifestsManifestNamePutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNamePutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNamePutExecute(r)
}

/*
SourceControlManifestsManifestNamePut Set release manifest

Push a branch to the source control repository that creates or updates the named release manifest. If the manifest exists, it will be overwritten in the branch. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNamePutRequest
*/
func (a *SourceControlAPIService) SourceControlManifestsManifestNamePut(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNamePutRequest {
	return ApiSourceControlManifestsManifestNamePutRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *SourceControlAPIService) SourceControlManifestsManifestNamePutExecute(r ApiSourceControlManifestsManifestNamePutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlManifestsManifestNamePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNamePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesAppsAppUuidGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	appUuid string
}

func (r ApiSourceControlReleasesAppsAppUuidGetRequest) Execute() (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesAppsAppUuidGetExecute(r)
}

/*
SourceControlReleasesAppsAppUuidGet Lists all available releases for the given app.

NOTE: This endpoint is deprecated. Use the GET /releases/{elementUuid} endpoint instead. 

Returns a list of the available releases for the app. The API token must have the "Source control > Releases (Read)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid of the app.
 @return ApiSourceControlReleasesAppsAppUuidGetRequest

Deprecated
*/
func (a *SourceControlAPIService) SourceControlReleasesAppsAppUuidGet(ctx context.Context, appUuid string) ApiSourceControlReleasesAppsAppUuidGetRequest {
	return ApiSourceControlReleasesAppsAppUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
	}
}

// Execute executes the request
//  @return SourceControlReleasesAppsAppUuidGet200Response
// Deprecated
func (a *SourceControlAPIService) SourceControlReleasesAppsAppUuidGetExecute(r ApiSourceControlReleasesAppsAppUuidGetRequest) (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlReleasesAppsAppUuidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlReleasesAppsAppUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesAppsAppUuidPostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	appUuid string
	sourceControlReleasesAppsAppUuidPostRequest *SourceControlReleasesAppsAppUuidPostRequest
}

func (r ApiSourceControlReleasesAppsAppUuidPostRequest) SourceControlReleasesAppsAppUuidPostRequest(sourceControlReleasesAppsAppUuidPostRequest SourceControlReleasesAppsAppUuidPostRequest) ApiSourceControlReleasesAppsAppUuidPostRequest {
	r.sourceControlReleasesAppsAppUuidPostRequest = &sourceControlReleasesAppsAppUuidPostRequest
	return r
}

func (r ApiSourceControlReleasesAppsAppUuidPostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesAppsAppUuidPostExecute(r)
}

/*
SourceControlReleasesAppsAppUuidPost Create a release artifact

NOTE: This endpoint is deprecated. Use the POST /releases/{elementUuid} endpoint instead. 

Push a branch to the source control repository that creates a new release artifact with the provided version for the app based on the latest version. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid of the app.
 @return ApiSourceControlReleasesAppsAppUuidPostRequest

Deprecated
*/
func (a *SourceControlAPIService) SourceControlReleasesAppsAppUuidPost(ctx context.Context, appUuid string) ApiSourceControlReleasesAppsAppUuidPostRequest {
	return ApiSourceControlReleasesAppsAppUuidPostRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *SourceControlAPIService) SourceControlReleasesAppsAppUuidPostExecute(r ApiSourceControlReleasesAppsAppUuidPostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlReleasesAppsAppUuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlReleasesAppsAppUuidPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesElementUuidGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	elementUuid string
	elementType *string
}

// The type of the element.
func (r ApiSourceControlReleasesElementUuidGetRequest) ElementType(elementType string) ApiSourceControlReleasesElementUuidGetRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlReleasesElementUuidGetRequest) Execute() (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesElementUuidGetExecute(r)
}

/*
SourceControlReleasesElementUuidGet Lists all available releases for the given element.

Returns a list of the available releases for the element. The API token must have the "Source control > Releases (Read)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid of the element.
 @return ApiSourceControlReleasesElementUuidGetRequest
*/
func (a *SourceControlAPIService) SourceControlReleasesElementUuidGet(ctx context.Context, elementUuid string) ApiSourceControlReleasesElementUuidGetRequest {
	return ApiSourceControlReleasesElementUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
	}
}

// Execute executes the request
//  @return SourceControlReleasesAppsAppUuidGet200Response
func (a *SourceControlAPIService) SourceControlReleasesElementUuidGetExecute(r ApiSourceControlReleasesElementUuidGetRequest) (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlReleasesAppsAppUuidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlReleasesElementUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesElementUuidPostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	elementUuid string
	elementType *string
	sourceControlReleasesAppsAppUuidPostRequest *SourceControlReleasesAppsAppUuidPostRequest
}

// The type of the element.
func (r ApiSourceControlReleasesElementUuidPostRequest) ElementType(elementType string) ApiSourceControlReleasesElementUuidPostRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlReleasesElementUuidPostRequest) SourceControlReleasesAppsAppUuidPostRequest(sourceControlReleasesAppsAppUuidPostRequest SourceControlReleasesAppsAppUuidPostRequest) ApiSourceControlReleasesElementUuidPostRequest {
	r.sourceControlReleasesAppsAppUuidPostRequest = &sourceControlReleasesAppsAppUuidPostRequest
	return r
}

func (r ApiSourceControlReleasesElementUuidPostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesElementUuidPostExecute(r)
}

/*
SourceControlReleasesElementUuidPost Create a release artifact

Push a branch to the source control repository that creates a new release artifact with the provided version for the element based on the latest version. The API token must have the "Source control > Releases (Write)" scope.

This feature is in beta. Reach out to support if you’d like to join the beta.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid of the element.
 @return ApiSourceControlReleasesElementUuidPostRequest
*/
func (a *SourceControlAPIService) SourceControlReleasesElementUuidPost(ctx context.Context, elementUuid string) ApiSourceControlReleasesElementUuidPostRequest {
	return ApiSourceControlReleasesElementUuidPostRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *SourceControlAPIService) SourceControlReleasesElementUuidPostExecute(r ApiSourceControlReleasesElementUuidPostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlReleasesElementUuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlReleasesAppsAppUuidPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlSettingsGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlSettingsGetRequest) Execute() (*SourceControlSettingsGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlSettingsGetExecute(r)
}

/*
SourceControlSettingsGet Get source control settings

Returns the source control settings for the organization or space. The API token must have the "Source Control > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlSettingsGetRequest
*/
func (a *SourceControlAPIService) SourceControlSettingsGet(ctx context.Context) ApiSourceControlSettingsGetRequest {
	return ApiSourceControlSettingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlSettingsGet200Response
func (a *SourceControlAPIService) SourceControlSettingsGetExecute(r ApiSourceControlSettingsGetRequest) (*SourceControlSettingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlSettingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlSettingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlSettingsPutRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	sourceControlSettingsPutRequest *SourceControlSettingsPutRequest
}

func (r ApiSourceControlSettingsPutRequest) SourceControlSettingsPutRequest(sourceControlSettingsPutRequest SourceControlSettingsPutRequest) ApiSourceControlSettingsPutRequest {
	r.sourceControlSettingsPutRequest = &sourceControlSettingsPutRequest
	return r
}

func (r ApiSourceControlSettingsPutRequest) Execute() (*SourceControlSettingsPut200Response, *http.Response, error) {
	return r.ApiService.SourceControlSettingsPutExecute(r)
}

/*
SourceControlSettingsPut Set source control settings

Creates or updates source control settings for the organization or space. This will overwrite existing settings. The API token must have the "Source Control > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlSettingsPutRequest
*/
func (a *SourceControlAPIService) SourceControlSettingsPut(ctx context.Context) ApiSourceControlSettingsPutRequest {
	return ApiSourceControlSettingsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlSettingsPut200Response
func (a *SourceControlAPIService) SourceControlSettingsPutExecute(r ApiSourceControlSettingsPutRequest) (*SourceControlSettingsPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlSettingsPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlSettingsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlSettingsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlTestConnectionGetRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
}

func (r ApiSourceControlTestConnectionGetRequest) Execute() (*SourceControlTestConnectionGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlTestConnectionGetExecute(r)
}

/*
SourceControlTestConnectionGet Tests source control connection

Tests the connection to the source control provider. Returns a boolean for whether the connection was successful or not. The API token must have the "Source Control > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlTestConnectionGetRequest
*/
func (a *SourceControlAPIService) SourceControlTestConnectionGet(ctx context.Context) ApiSourceControlTestConnectionGetRequest {
	return ApiSourceControlTestConnectionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlTestConnectionGet200Response
func (a *SourceControlAPIService) SourceControlTestConnectionGetExecute(r ApiSourceControlTestConnectionGetRequest) (*SourceControlTestConnectionGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlTestConnectionGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlTestConnectionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/test_connection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlTestDeployPostRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	sourceControlTestDeployPostRequest *SourceControlTestDeployPostRequest
}

func (r ApiSourceControlTestDeployPostRequest) SourceControlTestDeployPostRequest(sourceControlTestDeployPostRequest SourceControlTestDeployPostRequest) ApiSourceControlTestDeployPostRequest {
	r.sourceControlTestDeployPostRequest = &sourceControlTestDeployPostRequest
	return r
}

func (r ApiSourceControlTestDeployPostRequest) Execute() (*SourceControlTestDeployPost200Response, *http.Response, error) {
	return r.ApiService.SourceControlTestDeployPostExecute(r)
}

/*
SourceControlTestDeployPost Test source control changes

Attempts a test deployment (no permanent changes) using the provided commit SHA in order to determine whether the commit is valid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlTestDeployPostRequest
*/
func (a *SourceControlAPIService) SourceControlTestDeployPost(ctx context.Context) ApiSourceControlTestDeployPostRequest {
	return ApiSourceControlTestDeployPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlTestDeployPost200Response
func (a *SourceControlAPIService) SourceControlTestDeployPostExecute(r ApiSourceControlTestDeployPostRequest) (*SourceControlTestDeployPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlTestDeployPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.SourceControlTestDeployPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/test_deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlTestDeployPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
