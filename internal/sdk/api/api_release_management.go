/*
Retool API

Go to Settings > API to get started. Once you generate an API token, use bearer token authentication to make requests.

API version: 2.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ReleaseManagementAPIService ReleaseManagementAPI service
type ReleaseManagementAPIService service

type ApiSourceControlManifestsGetRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
}

func (r ApiSourceControlManifestsGetRequest) Execute() (*SourceControlManifestsGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsGetExecute(r)
}

/*
SourceControlManifestsGet Lists all release manifests

Returns a list of all release manifests available in the source control repository. The API token must have the "Source control > Releases (Read)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSourceControlManifestsGetRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsGet(ctx context.Context) ApiSourceControlManifestsGetRequest {
	return ApiSourceControlManifestsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceControlManifestsGet200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsGetExecute(r ApiSourceControlManifestsGetRequest) (*SourceControlManifestsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	appUuid string
	manifestName string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameAppsAppUuidDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameAppsAppUuidDeletePost Delete the entry for an app from a release manifest

NOTE: This endpoint is deprecated. Use the DELETE /manifests/{manifestName}/{elementUuid} endpoint instead. 

Push a branch to the source control repository that deletes the entry for the specified app from the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid to specify an app of interest within the release manifest. This should be the uuid found in the source control repository, which may differ from the organization specific uuid.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest

Deprecated
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameAppsAppUuidDeletePost(ctx context.Context, appUuid string, manifestName string) ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest {
	return ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameAppsAppUuidDeletePostExecute(r ApiSourceControlManifestsManifestNameAppsAppUuidDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameAppsAppUuidDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/apps/{appUuid}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	appUuid string
	manifestName string
	sourceControlManifestsManifestNameAppsAppUuidPutRequest *SourceControlManifestsManifestNameAppsAppUuidPutRequest
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) SourceControlManifestsManifestNameAppsAppUuidPutRequest(sourceControlManifestsManifestNameAppsAppUuidPutRequest SourceControlManifestsManifestNameAppsAppUuidPutRequest) ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest {
	r.sourceControlManifestsManifestNameAppsAppUuidPutRequest = &sourceControlManifestsManifestNameAppsAppUuidPutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameAppsAppUuidPutExecute(r)
}

/*
SourceControlManifestsManifestNameAppsAppUuidPut Set release configuration for app in manifest

NOTE: This endpoint is deprecated. Use the PUT /manifests/{manifestName}/{elementUuid} endpoint instead. 

Push a branch to the source control repository that updates the release version of the specified app in the named release manifest. If the manifest does not already exist, it will be created in the branch. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid to specify an app of interest within the release manifest. This should be the uuid found in the source control repository, which may differ from the organization specific uuid.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest

Deprecated
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameAppsAppUuidPut(ctx context.Context, appUuid string, manifestName string) ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest {
	return ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameAppsAppUuidPutExecute(r ApiSourceControlManifestsManifestNameAppsAppUuidPutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameAppsAppUuidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameAppsAppUuidPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameDeletePostRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	manifestName string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

func (r ApiSourceControlManifestsManifestNameDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameDeletePost Delete a release manifest

Push a branch to the source control repository that deletes the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameDeletePostRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameDeletePost(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNameDeletePostRequest {
	return ApiSourceControlManifestsManifestNameDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameDeletePostExecute(r ApiSourceControlManifestsManifestNameDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	elementUuid string
	manifestName string
	elementType *string
	sourceControlManifestsManifestNameDeletePostRequest *SourceControlManifestsManifestNameDeletePostRequest
}

// The type of the element.
func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) ElementType(elementType string) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) SourceControlManifestsManifestNameDeletePostRequest(sourceControlManifestsManifestNameDeletePostRequest SourceControlManifestsManifestNameDeletePostRequest) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	r.sourceControlManifestsManifestNameDeletePostRequest = &sourceControlManifestsManifestNameDeletePostRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameElementUuidDeletePostExecute(r)
}

/*
SourceControlManifestsManifestNameElementUuidDeletePost Delete element from release manifest

Push a branch to the source control repository that deletes the entry for the specified element from the named release manifest. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid to specify an element of interest within the release manifest.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameElementUuidDeletePost(ctx context.Context, elementUuid string, manifestName string) ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest {
	return ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameElementUuidDeletePostExecute(r ApiSourceControlManifestsManifestNameElementUuidDeletePostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameElementUuidDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/{elementUuid}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameDeletePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameElementUuidPutRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	elementUuid string
	manifestName string
	elementType *string
	sourceControlManifestsManifestNameAppsAppUuidPutRequest *SourceControlManifestsManifestNameAppsAppUuidPutRequest
}

// The type of the element.
func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) ElementType(elementType string) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) SourceControlManifestsManifestNameAppsAppUuidPutRequest(sourceControlManifestsManifestNameAppsAppUuidPutRequest SourceControlManifestsManifestNameAppsAppUuidPutRequest) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	r.sourceControlManifestsManifestNameAppsAppUuidPutRequest = &sourceControlManifestsManifestNameAppsAppUuidPutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNameElementUuidPutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameElementUuidPutExecute(r)
}

/*
SourceControlManifestsManifestNameElementUuidPut Set release version for element in manifest

Push a branch to the source control repository that updates the release version of the specified element in the named release manifest. If the manifest does not already exist, it will be created in the branch. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid to specify an element of interest within the release manifest.
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameElementUuidPutRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameElementUuidPut(ctx context.Context, elementUuid string, manifestName string) ApiSourceControlManifestsManifestNameElementUuidPutRequest {
	return ApiSourceControlManifestsManifestNameElementUuidPutRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameElementUuidPutExecute(r ApiSourceControlManifestsManifestNameElementUuidPutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameElementUuidPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNameAppsAppUuidPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNameGetRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	manifestName string
}

func (r ApiSourceControlManifestsManifestNameGetRequest) Execute() (*SourceControlManifestsManifestNameGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNameGetExecute(r)
}

/*
SourceControlManifestsManifestNameGet Get a specific release manifest

Returns the release manifest with the specified name from the source control repository if it exists. The API token must have the "Source control > Releases (Read)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNameGetRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameGet(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNameGetRequest {
	return ApiSourceControlManifestsManifestNameGetRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNameGet200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNameGetExecute(r ApiSourceControlManifestsManifestNameGetRequest) (*SourceControlManifestsManifestNameGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNameGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlManifestsManifestNamePutRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	manifestName string
	sourceControlManifestsManifestNamePutRequest *SourceControlManifestsManifestNamePutRequest
}

func (r ApiSourceControlManifestsManifestNamePutRequest) SourceControlManifestsManifestNamePutRequest(sourceControlManifestsManifestNamePutRequest SourceControlManifestsManifestNamePutRequest) ApiSourceControlManifestsManifestNamePutRequest {
	r.sourceControlManifestsManifestNamePutRequest = &sourceControlManifestsManifestNamePutRequest
	return r
}

func (r ApiSourceControlManifestsManifestNamePutRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlManifestsManifestNamePutExecute(r)
}

/*
SourceControlManifestsManifestNamePut Set release manifest

Push a branch to the source control repository that creates or updates the named release manifest. If the manifest exists, it will be overwritten in the branch. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manifestName Identifier for the manifest of interest
 @return ApiSourceControlManifestsManifestNamePutRequest
*/
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNamePut(ctx context.Context, manifestName string) ApiSourceControlManifestsManifestNamePutRequest {
	return ApiSourceControlManifestsManifestNamePutRequest{
		ApiService: a,
		ctx: ctx,
		manifestName: manifestName,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *ReleaseManagementAPIService) SourceControlManifestsManifestNamePutExecute(r ApiSourceControlManifestsManifestNamePutRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlManifestsManifestNamePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/manifests/{manifestName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manifestName"+"}", url.PathEscape(parameterValueToString(r.manifestName, "manifestName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlManifestsManifestNamePutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesAppsAppUuidGetRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	appUuid string
}

func (r ApiSourceControlReleasesAppsAppUuidGetRequest) Execute() (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesAppsAppUuidGetExecute(r)
}

/*
SourceControlReleasesAppsAppUuidGet Lists all available releases for the given app.

NOTE: This endpoint is deprecated. Use the GET /releases/{elementUuid} endpoint instead. 

Returns a list of the available releases for the app. The API token must have the "Source control > Releases (Read)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid of the app.
 @return ApiSourceControlReleasesAppsAppUuidGetRequest

Deprecated
*/
func (a *ReleaseManagementAPIService) SourceControlReleasesAppsAppUuidGet(ctx context.Context, appUuid string) ApiSourceControlReleasesAppsAppUuidGetRequest {
	return ApiSourceControlReleasesAppsAppUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
	}
}

// Execute executes the request
//  @return SourceControlReleasesAppsAppUuidGet200Response
// Deprecated
func (a *ReleaseManagementAPIService) SourceControlReleasesAppsAppUuidGetExecute(r ApiSourceControlReleasesAppsAppUuidGetRequest) (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlReleasesAppsAppUuidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlReleasesAppsAppUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesAppsAppUuidPostRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	appUuid string
	sourceControlReleasesAppsAppUuidPostRequest *SourceControlReleasesAppsAppUuidPostRequest
}

func (r ApiSourceControlReleasesAppsAppUuidPostRequest) SourceControlReleasesAppsAppUuidPostRequest(sourceControlReleasesAppsAppUuidPostRequest SourceControlReleasesAppsAppUuidPostRequest) ApiSourceControlReleasesAppsAppUuidPostRequest {
	r.sourceControlReleasesAppsAppUuidPostRequest = &sourceControlReleasesAppsAppUuidPostRequest
	return r
}

func (r ApiSourceControlReleasesAppsAppUuidPostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesAppsAppUuidPostExecute(r)
}

/*
SourceControlReleasesAppsAppUuidPost Create a release artifact

NOTE: This endpoint is deprecated. Use the POST /releases/{elementUuid} endpoint instead. 

Push a branch to the source control repository that creates a new release artifact with the provided version for the app based on the latest version. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appUuid The uuid of the app.
 @return ApiSourceControlReleasesAppsAppUuidPostRequest

Deprecated
*/
func (a *ReleaseManagementAPIService) SourceControlReleasesAppsAppUuidPost(ctx context.Context, appUuid string) ApiSourceControlReleasesAppsAppUuidPostRequest {
	return ApiSourceControlReleasesAppsAppUuidPostRequest{
		ApiService: a,
		ctx: ctx,
		appUuid: appUuid,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
// Deprecated
func (a *ReleaseManagementAPIService) SourceControlReleasesAppsAppUuidPostExecute(r ApiSourceControlReleasesAppsAppUuidPostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlReleasesAppsAppUuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/apps/{appUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"appUuid"+"}", url.PathEscape(parameterValueToString(r.appUuid, "appUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlReleasesAppsAppUuidPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesElementUuidGetRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	elementUuid string
	elementType *string
}

// The type of the element.
func (r ApiSourceControlReleasesElementUuidGetRequest) ElementType(elementType string) ApiSourceControlReleasesElementUuidGetRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlReleasesElementUuidGetRequest) Execute() (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesElementUuidGetExecute(r)
}

/*
SourceControlReleasesElementUuidGet Lists all available releases for the given element.

Returns a list of the available releases for the element. The API token must have the "Source control > Releases (Read)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid of the element.
 @return ApiSourceControlReleasesElementUuidGetRequest
*/
func (a *ReleaseManagementAPIService) SourceControlReleasesElementUuidGet(ctx context.Context, elementUuid string) ApiSourceControlReleasesElementUuidGetRequest {
	return ApiSourceControlReleasesElementUuidGetRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
	}
}

// Execute executes the request
//  @return SourceControlReleasesAppsAppUuidGet200Response
func (a *ReleaseManagementAPIService) SourceControlReleasesElementUuidGetExecute(r ApiSourceControlReleasesElementUuidGetRequest) (*SourceControlReleasesAppsAppUuidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlReleasesAppsAppUuidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlReleasesElementUuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSourceControlReleasesElementUuidPostRequest struct {
	ctx context.Context
	ApiService *ReleaseManagementAPIService
	elementUuid string
	elementType *string
	sourceControlReleasesAppsAppUuidPostRequest *SourceControlReleasesAppsAppUuidPostRequest
}

// The type of the element.
func (r ApiSourceControlReleasesElementUuidPostRequest) ElementType(elementType string) ApiSourceControlReleasesElementUuidPostRequest {
	r.elementType = &elementType
	return r
}

func (r ApiSourceControlReleasesElementUuidPostRequest) SourceControlReleasesAppsAppUuidPostRequest(sourceControlReleasesAppsAppUuidPostRequest SourceControlReleasesAppsAppUuidPostRequest) ApiSourceControlReleasesElementUuidPostRequest {
	r.sourceControlReleasesAppsAppUuidPostRequest = &sourceControlReleasesAppsAppUuidPostRequest
	return r
}

func (r ApiSourceControlReleasesElementUuidPostRequest) Execute() (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	return r.ApiService.SourceControlReleasesElementUuidPostExecute(r)
}

/*
SourceControlReleasesElementUuidPost Create a release artifact

Push a branch to the source control repository that creates a new release artifact with the provided version for the element based on the latest version. The API token must have the "Source control > Releases (Write)" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param elementUuid The uuid of the element.
 @return ApiSourceControlReleasesElementUuidPostRequest
*/
func (a *ReleaseManagementAPIService) SourceControlReleasesElementUuidPost(ctx context.Context, elementUuid string) ApiSourceControlReleasesElementUuidPostRequest {
	return ApiSourceControlReleasesElementUuidPostRequest{
		ApiService: a,
		ctx: ctx,
		elementUuid: elementUuid,
	}
}

// Execute executes the request
//  @return SourceControlManifestsManifestNamePut200Response
func (a *ReleaseManagementAPIService) SourceControlReleasesElementUuidPostExecute(r ApiSourceControlReleasesElementUuidPostRequest) (*SourceControlManifestsManifestNamePut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceControlManifestsManifestNamePut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseManagementAPIService.SourceControlReleasesElementUuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/source_control/releases/{elementUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"elementUuid"+"}", url.PathEscape(parameterValueToString(r.elementUuid, "elementUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "elementType", r.elementType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceControlReleasesAppsAppUuidPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FoldersPost409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
