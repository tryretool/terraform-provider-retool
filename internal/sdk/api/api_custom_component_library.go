/*
Retool API

Go to Settings > API to get started. Once you generate an API token, use bearer token authentication to make requests.

API version: 2.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// CustomComponentLibraryAPIService CustomComponentLibraryAPI service
type CustomComponentLibraryAPIService service

type ApiCustomComponentLibrariesGetRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	libraryId *string
}

func (r ApiCustomComponentLibrariesGetRequest) LibraryId(libraryId string) ApiCustomComponentLibrariesGetRequest {
	r.libraryId = &libraryId
	return r
}

func (r ApiCustomComponentLibrariesGetRequest) Execute() (*CustomComponentLibrariesGet200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesGetExecute(r)
}

/*
CustomComponentLibrariesGet Get a list of all custom component libraries

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Gets a paginated list of all custom component libraries. The API token must have the "CustomComponent > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomComponentLibrariesGetRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesGet(ctx context.Context) ApiCustomComponentLibrariesGetRequest {
	return ApiCustomComponentLibrariesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesGet200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesGetExecute(r ApiCustomComponentLibrariesGetRequest) (*CustomComponentLibrariesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.libraryId == nil {
		return localVarReturnValue, nil, reportError("libraryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "libraryId", r.libraryId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomComponentLibrariesLibraryIdGetRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	libraryId string
}

func (r ApiCustomComponentLibrariesLibraryIdGetRequest) Execute() (*CustomComponentLibrariesLibraryIdGet200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesLibraryIdGetExecute(r)
}

/*
CustomComponentLibrariesLibraryIdGet Get a single custom component libraries

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Gets a single custom component library. The API token must have the "CustomComponent > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @return ApiCustomComponentLibrariesLibraryIdGetRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdGet(ctx context.Context, libraryId string) ApiCustomComponentLibrariesLibraryIdGetRequest {
	return ApiCustomComponentLibrariesLibraryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesLibraryIdGet200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdGetExecute(r ApiCustomComponentLibrariesLibraryIdGetRequest) (*CustomComponentLibrariesLibraryIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesLibraryIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesLibraryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries/{libraryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	libraryId string
}

func (r ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest) Execute() (*CustomComponentLibrariesLibraryIdRevisionsGet200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesLibraryIdRevisionsGetExecute(r)
}

/*
CustomComponentLibrariesLibraryIdRevisionsGet Gets a list of all the revisions of a custom component library

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Gets a list of all the revisions of a custom component library. The API token must have the "CustomComponent > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @return ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsGet(ctx context.Context, libraryId string) ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest {
	return ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesLibraryIdRevisionsGet200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsGetExecute(r ApiCustomComponentLibrariesLibraryIdRevisionsGetRequest) (*CustomComponentLibrariesLibraryIdRevisionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesLibraryIdRevisionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesLibraryIdRevisionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries/{libraryId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	libraryId string
	versionBump *string
	files *os.File
	id *string
	version *string
}

func (r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) VersionBump(versionBump string) ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest {
	r.versionBump = &versionBump
	return r
}

func (r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) Files(files *os.File) ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest {
	r.files = files
	return r
}

// Specifies a specific id to use for the library. Used for syncronizing libraries across Retool Instances.
func (r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) Id(id string) ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest {
	r.id = &id
	return r
}

// A specific version tag to use. Also specify version_bump as &#39;specify_version&#39;.
func (r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) Version(version string) ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest {
	r.version = &version
	return r
}

func (r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) Execute() (*CustomComponentLibrariesLibraryIdRevisionsPost200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesLibraryIdRevisionsPostExecute(r)
}

/*
CustomComponentLibrariesLibraryIdRevisionsPost Create a new custom component library revision

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Creates a new version of a custom component library, the underlying files that describe the component. The API token must have the "CustomComponent > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @return ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsPost(ctx context.Context, libraryId string) ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest {
	return ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesLibraryIdRevisionsPost200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsPostExecute(r ApiCustomComponentLibrariesLibraryIdRevisionsPostRequest) (*CustomComponentLibrariesLibraryIdRevisionsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesLibraryIdRevisionsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesLibraryIdRevisionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries/{libraryId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.versionBump == nil {
		return localVarReturnValue, nil, reportError("versionBump is required and must be specified")
	}
	if r.files == nil {
		return localVarReturnValue, nil, reportError("files is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "version_bump", r.versionBump, "")
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "version", r.version, "")
	}
	var filesLocalVarFormFileName string
	var filesLocalVarFileName     string
	var filesLocalVarFileBytes    []byte

	filesLocalVarFormFileName = "files"
	filesLocalVarFile := r.files

	if filesLocalVarFile != nil {
		fbs, _ := io.ReadAll(filesLocalVarFile)

		filesLocalVarFileBytes = fbs
		filesLocalVarFileName = filesLocalVarFile.Name()
		filesLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filesLocalVarFileBytes, fileName: filesLocalVarFileName, formFileName: filesLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	libraryId string
	revisionId string
}

func (r ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest) Execute() (*CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetExecute(r)
}

/*
CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet Gets all files associated with a custom component library revision.

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Gets all files associated with a custom component library revision. The API token must have the "CustomComponent > Read" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param revisionId
 @return ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet(ctx context.Context, libraryId string, revisionId string) ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest {
	return ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetExecute(r ApiCustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGetRequest) (*CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesLibraryIdRevisionsRevisionIdFilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries/{libraryId}/revisions/{revisionId}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomComponentLibrariesPostRequest struct {
	ctx context.Context
	ApiService *CustomComponentLibraryAPIService
	customComponentLibrariesPostRequest *CustomComponentLibrariesPostRequest
}

func (r ApiCustomComponentLibrariesPostRequest) CustomComponentLibrariesPostRequest(customComponentLibrariesPostRequest CustomComponentLibrariesPostRequest) ApiCustomComponentLibrariesPostRequest {
	r.customComponentLibrariesPostRequest = &customComponentLibrariesPostRequest
	return r
}

func (r ApiCustomComponentLibrariesPostRequest) Execute() (*CustomComponentLibrariesPost200Response, *http.Response, error) {
	return r.ApiService.CustomComponentLibrariesPostExecute(r)
}

/*
CustomComponentLibrariesPost Create a new custom component library

Available on Retool Cloud and self-hosted Retool version 3.41.0+. Creates a new custom component library The API token must have the "CustomComponent > Write" scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomComponentLibrariesPostRequest
*/
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesPost(ctx context.Context) ApiCustomComponentLibrariesPostRequest {
	return ApiCustomComponentLibrariesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomComponentLibrariesPost200Response
func (a *CustomComponentLibraryAPIService) CustomComponentLibrariesPostExecute(r ApiCustomComponentLibrariesPostRequest) (*CustomComponentLibrariesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomComponentLibrariesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomComponentLibraryAPIService.CustomComponentLibrariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom_component_libraries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customComponentLibrariesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
